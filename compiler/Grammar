PROGRAM ::= IMPORT* CLASS_DEFN*

IMPORT ::= `import` MODULE_ID ;

MODULE_ID = [a-zA-z](.[a-zA-Z_]+)*

CLASS_DEFN ::= (`public`|`private`)? `class` `{` CLASS_BODY `}`

CLASS_BODY ::= (FIELD_DEFN | METHOD_DEFN)*

TYPE_ID ::= id

FIELD_DEFN ::= (`public`|`private)? `static`? `final`? TYPE_ID id (= EXPRESSION)? ;

METHOD_DEFN ::= (`public`|`private`)? `static`? `final`? TYPE_ID id `(` PARAM_LIST `)`
                BLOCK_STMT

PARAM_LIST ::= EMPTY | (TYPE_ID id) (`,` TYPE_ID id)*

STATEMENT ::= HANGING_STMT `;` | BLOCK_STMT | ';` | IF_STMT | FOR_STMT |
                WHILE_STMT

HANGING_STMT ::= VAR_DECL | ASSIGN | EXPRESSION | `return` EXPRESSION

VAR_DECL ::= `final`? TYPE_ID ASSIGN

SINGLE_ASSIGN ::= id `=` EXPRESSION

ASSIGN ::= SINGLE_ASSIGN (`,` SINGLE_ASSIGN)*

BLOCK_STMT ::= `{` STATEMENT* `}`

FOR_STMT ::= `for` '(` STATEMENT EXPRESSION? `;` HANGING_STMT? `)` STATEMENT

WHILE_STMT ::= `while` '(` EXPRESSION `)` STATEMENT

IF_STMT ::= `if` `(` EXPRESSION `)` STATEMENT (`else` `if` `(` EXPRESSION `)` STATEMENT)* (`else` STATEMENT)?

;; Expressions are ultimately constructed out of literals, ids and member refs,
;; which we call atoms. Starting with atoms, complex expressions like
;; arithmetic, comparision and logical expressions are constructed.

;; For the first version, let's only worry about arithmetic expressions.

EXPRESSION ::= ARITH | `(` EXPRESSION `)` | ATOM

ATOM ::= MEMBER_REF | literal | id

METHOD_CALL ::= id METHOD_ARGS

METHOD_ARGS ::= `(` (EMPTY | EXPRESSION (`,` EXPRESSION)*) `)`

MEMBER_REF ::= id METHOD_ARGS? (`.` id METHOD_ARGS?)*

PLUS_MINUS ::= `+` | `-`

M_D_MOD ::= `*` | `/` | `%`

ARITH ::= PLUS_MINUS? ARITH_TERM (PLUS_MINUS ARITH_TERM)*

ARITH_TERM ::= ARITH_FACTOR (M_D_MOD ARITH_FACTOR)*

ARITH_FACTOR ::= PLUS_MINUS ARITH_FACTOR | `(` ARITH_EXPR `)` | ATOM
