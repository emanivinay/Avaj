;; Syntactic spec for Avaj.
;; Lines starting with `;' are comments and can be ignored.
;; Each production is specified as NON_TERMINAL ::= SYMBOL_STRING, where
;; SYMBOL_string is a string of grammar symbols(terminals or non-terminals).

;; Any word not entirely in upper case in a production stands for a terminal, 
;; with parsing for the terminal already done in the Lexer phase.

;; Within the RHS of a production, whitespace is insignificant. Avaj being a 
;; free-form language, whitespace is insignificant even in source code, with
;; the only exception being when it's present inside a char/string literal.

;; Within a production, an expression like A* stands for zero or more
;; repetitions of the symbol A.

;; The grammar shall be unambiguous, with no left recursion and must be left
;; factored. This allows for a top-down parsing approach.


PROGRAM ::= IMPORT* CLASS_DEFN*

IMPORT ::= import MODULE_ID ;

MODULE_ID = [a-zA-z_](.[a-zA-Z_]+)*

CLASS_DEFN ::= (public|private)? class { CLASS_BODY }

CLASS_BODY ::= (FIELD_DEFN | METHOD_DEFN)*

FIELD_DEFN ::= (public|private)? static? final? id (= EXPRESSION)? ;

METHOD_DEFN ::= (public|private)? static? final? id id lparen PARAM_LIST rparen 
                BLOCK_STATEMENT

PARAM_LIST ::= EMPTY | ID ID (, ID ID)*

EXPRESSION ::= new id lparen METHOD_ARGS rparen | ARITH_EXPR | LOGICAL_EXPR |
                LITERAL_EXPR | MEMBER_REF

MEMBER_REF ::= tbd

METHOD_ARGS ::= EMPTY | EXPRESSION (, EXPRESSION)*

ARITH_EXPR ::= tbd

LOGICAL_EXPR ::= tbd

LITERAL_EXPR ::= number | string | true | false

STATEMENT ::= EXPRESSION | VAR_DECL | ASSIGNMENT | empty | RETURN_STATEMENT |
                BLOCK_STATEMENT

VAR_DECL ::= id ASSIGNMENT

ASSIGNMENT ::= (id = EXPRESSION , )* (id = EXPRESSION) ;

RETURN_STATEMENT ::= return EXPRESSION ;

BLOCK_STATEMENT ::= { STATEMENT* }
